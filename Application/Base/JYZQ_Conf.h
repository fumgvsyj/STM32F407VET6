//
// Created by 34753 on 2024/9/22.
//
#ifndef FURINA_JYZQ_CONF_H
#define FURINA_JYZQ_CONF_H
/**
 * @brief JY与ZQ协同开发の配置文件
 * @details 若有不同意见再共同磋商，其余且看且行
 * @note
 * 【接口兼容性】：BSP统一使用C接口。而模块级与应用级则使用C++接口，方便开发，比如可以使用重载、引用、自动类型推导、lambda表达式、返回类型后置、结构化绑定等
 * 【文件命名规范】：BSP和模块级小写为主，不同属性用下划线隔开，方便调用接口；应用级采用驼峰命名法
 * 【函数】：
 *      BSP：为了提高驱动性能，实现简单功能的函数尽量内敛，其内局部变量尽量使用字长单位
 * 【变量】：尽量不使用全局变量
 *      BSP：尽量使用函数式编程，减少副作用
 * 【调试】：统一开-O2级别优化，遇到问题再开-Og。在CLion里面体现为使用Release选项。同时要注意volatile变量的使用
 * 【语法使用规范】：由于单片机资源有限，不能使用泛型编程如模版。类可以使用，尽量使用静态类以实现零成本抽象，避免实例化对象，尤其是new的使用。
 */

// C++中适合单片机开发的新特性，C++11以后每三年一个版本，且按照Major-Minor-Minor进行迭代
// C++20与C++23基本都是对标准库、泛型编程等进行了优化，很难用到单片机上。尤其是那该死的模块，听说MSVC支持的比较好，cmake也还行，但是试来试去就是不行，淦。
/**
 * // -------------------------------------C++11-------------------------------------
 *
 * 【constexpr】：允许在编译时计算常量表达式，减少了运行时的开销。C++20中进一步提升了性能
 *      constexpr int square(int x) {return x * x;}
 *      constexpr int result = square(5);  // result 在编译时计算
 *
 * 【范围-based for 循环】：允许在循环中迭代容器中的元素，简化代码。即简化了索引操作，避免潜在管理错误
 *      for (auto& elem : array) {elem *= 2;}
 *
 * 【自动类型推导】：允许在函数参数中省略类型声明，让编译器自动推导类型。这个没什么好说的。但是要注意使用场合，像【范围-based for 循环】、【lambda表达式】
 *                等一些类型复杂或者显而易见的场景，这样做可以让代码简洁。对于类型不明显或容易混淆的场景，比如基本类型变量、函数参数、等，还是建议显式声明类型，避免使用泛滥
 *      auto add(int a, int b) {return a + b; }// 可以推导出返回值类型为 int，与返回类型后置差不多
 *
 *  // -------------------------------------C++14-------------------------------------
 *
 *  【泛型 lambda 表达式】：允许在函数内部定义lambda表达式，使得代码更加简洁，不再又是声明又是定义的。
 *          auto print = [](auto x) {std::cout << x << std::endl;};
 *
 *  【返回类型后置】：这他宝贝的才是我喜欢的函数定义语法，跟Koltin里一样，可以使复杂的函数签名更易读。只不过前面还是要加上auto真是麻烦
 *          auto square(int x) -> int { return x * x;}
 *
 * // -------------------------------------C++17-------------------------------------
 *
 * 【if 和 switch 初始化器 】：允许在if语句和switch语句中初始化变量。避免局部变量到处都是，全他宝贝的污染
 *      比如：if (auto value = read_sensor(); value > threshold){}
 *
 * 【[[nodiscard]]】：用来标记函数返回值不应该被忽略，防止潜在错误
 *      比如：[[nodiscard]] bool check_error() {}
 *
 * 【结构化绑定】：跟Koltin里的解构差不多，就是当函数返回值类型为结构体之类的，可以让函数返回多个值
 *      std::pair<int, int> coords = get_coordinates();
 *      auto [x, y] = get_coordinates();
 *
 * 【内联变量】：可以在头文件中直接定义静态成员变量，而不会导致重复定义的问题。这个嘛不一定用得上
 */


/**************************调试*************************/
// 是否开启FreeRTOS调试模式
// 调试时，开了之后在负荷不大的情况下，也并不怎么影响实时性。发行时记得关闭
#define FreeRTOS_DebugMode  1


/************************应用级***************************/
#define ENABLE_VOICE_STORAGE_AND_PLAY 1
#define ENABLE_KEY_TASK_HANDLE 1


/*************************模块级**************************/
#define USE_

/**************************板级**************************/
#define USE_FSMC 1  // 使用FSMC
#define USE_LCD 1   // 使用LCD
#define USE_KEY_EXTI  1// 使用按键的外部中断








#endif //FURINA_JYZQ_CONF_H
